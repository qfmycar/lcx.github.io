### 一、垃圾回收机制

```
	垃圾回收分为两步，一是筛选对象，二是清理对象。
```

#### 1、算法

##### 1.引用计数法

```
	一个对象它多一个引用就会计数加1，反正则会减1。这个是吧计数为0的对象标记筛选出来。
	优点：高效				缺点：不能处理循环引用中的对象
```

##### 2.根搜索算法

```
	从根节点往下寻找，形成一条链式结构，如果一个对象到根节点没有任何引用链相连，则这个对象没有引用
```

##### 3.标记—清除

```
	分两步。1、从根节点标记所有被引用的对象；2、把所有未被引用的对象删除
	优点: 简单高效							缺点：易产生内存碎片，会暂停整个应用
```

##### 4.复制

```
	使用两块相同大小的内存区域，分别为A和B。当A中内存写满时，将A中存活对象全移到B中并且整理，再清空A区。
	优点：只处理存活的对象，复制成本小，不会产生内存碎片		缺点：需要两倍的内存来管理对应的区域
```

##### 5.标记—整理

```
	结合清除和复制算法，在对象被清除的基础上，将所有存活对象移到堆中的一块区域并且进行整理
    优点：不会产生内存碎片，不需要过多内存来管理		缺点：效率比清除低些
```

##### 6.按对象的生命周期长短进行分代

```
	将对象分为年轻代、年老代、持久代。不同生命周期的对象使用不同的算法来回收
```

#### 2、分代

```
	根据对象生命周期的长短，可以将内存分为  年轻代、年老代、持久代
	年轻代有大量对象死去，所以使用复制算法
	年老代对象存活时间较长，所以使用“标记-清理” 或 “标记-整理”
```

##### 1.年轻代(新生代)

```java
	大多数对象会先创建在Eden区域，当Eden区写满时，Eden区中存活的对象会随机复制到某个Survivor区中，当这个Survivor区也被写满时，这个Survivor区存活的对象会被复制到另一个Survivor区。当另一个Survivor区写满时，存活的对象会被复制到年老代中去。
	这两个Survivor是相同大小不分先后的，所以会存在某个Survivor区同时存在从Eden区复制来的对象和从另一个Survivor复制来的对象。但是，复制到年老代的对象，必须是经过Eden-Survivor-另一个Survivor完整路径的对象。
```

##### 2.年老代(老年代)

```
	里面存储从年轻代复制来的对象，生命周期较长。当年老代被写满时，会把存活对象复制到持久代中。
```

##### 3.持久代(永久代)

```java
	存储静态文件，如静态对象、静态方法等。
	持久代对垃圾回收没有大的影响，但是有些程序会调用会生成一些class文件，比如Hibernate。此时要配置一个较大的持久代空间来存放新增的类。
	持久代大小可通过 -XX:MaxPermSize = 来设置
```

### 二、GC方式

##### 1、Scavenge GC

```
	年轻代内Eden或Survivor区被写满时，执行Scavenge GC，清空区域中的对象
```

##### 2、Full GC

```
	对堆进行遍历清除，一般不推荐使用，一下几种情况会触发此GC方式
	1.年老代被写满
	2.持久代被写满
	3.使用 System.gc()方法
	4.上次GC执行后，堆(Heap)中的各域分配策略发生变化
```

### 三、垃圾收集器

##### 1、串行收集器

```java
	使用单线程串行年轻代，串行标记-清扫-缩并。因为是单线程的，所以效率高，但是无法使用多处理器的优点。
    适用：数据量小(100M左右)；单处理器并对响应时间无要求；多处理器的小数据量处理
    缺点：只能用于小型应用
    用： -XX：+UseSerialGC		打开
```

##### 2、并行收集器

```java
	并行年轻代，串行标记-清扫-缩并。
	对年轻代进行并行垃圾回收，可以减少垃圾回收时间，一般在多处理器机器上使用
	用： -XX:+UseParallelGC 		打开
	
	在Java SE6.0中，可以对老年代进行垃圾收集
	如果老年代不用并发收集，而是单线程收集，会影响它的扩展能力
	用： -XX:+UseParallelOldGC	打开
	
	适用：对吞吐量有要求，多CPU，对响应时间无要求的中大型应用（如后台）
	缺点：响应时间可能较长
```

##### 3、并发收集器

```java
	并发年轻代，初始标记、并发标记、重新标记、并发清扫、重置
	1、并发收集器主要减少老年代GC时的暂停时间，它在应用不停止的情况下，用独立的线程回收垃圾。在年老代垃圾回收中，刚开始会有一次暂停，然后执行中期也会有一次暂停，这次暂停比开始时的暂停久些。在这整个过程中，多个线程同时进行垃圾回收
	2、并发收集器使用处理器换取短暂的停顿时间。在一个N个处理器的机器，并发收集使用K/N个处理器，1<=K<=N
	3、在只有一个处理器的机器上使用并发收集器，使用incremental mode 模式也可以获得较短的停顿时间
	4、浮动垃圾(Floating Garbage)：应用运行时也会进行垃圾回收，所以有些垃圾会在垃圾回收完成时产生。这样就造成了浮动垃圾，这些垃圾会在下次GC时被清理，所以并发收集器需要预留20%的空间来存放浮动垃圾
	5、Concurrent Mode Failure：因为并发收集器在应用运行时收集，所以需要堆有足够的空间供程序使用，否则垃圾收集还没完成，堆就已经满了。这种情况会发送“并发模式失败”，从而暂停应用，进行垃圾回收
	6、启动并发收集器
	   -XX：CMSInitiatingOccupancyFraction =       //指定还有多少剩余堆时，进行并发垃圾收集
		
    适用：对响应时间要求高，多CPU的中大型应用（如Web服务器）
```

### 四、常见配置举例

```java
	堆大小由三点限制：1.操作系统的数据模型	2.虚拟内存	3.物理内存
	32位系统下，一般限制为1.5G~2G
	64位系统下，对内存无限制
```

##### 1、典型设置

```java
-XX:+<option>		开启option选项
-XX:-<option>		关闭option选项
-XX:<option><value>	 把option选项的值设为value

-Xmx3550m：JVM最大内存3550M		
-Xms3550m：JVM初始内存3550M，这个值与Xmx相同可避免每次GC后JVM重新分配内存
-Xmn2g：年轻代内存2G。堆 = 年轻代 + 年老代 + 持久代。持久代一般固定为64m，所以增加年轻代会减少年老代
-Xss128k：每个线程的堆栈大小为128K。JDK5.0后，每个线程大小为1M，之前为256K。相同物理内存，减少此值会生			 成更多线程，但不会无限生成，一般在3K~5K之间
-XX:new Ratio = 4：年轻代与年老代的比值，此处为1:4，年轻代占堆的1/5，逻辑上持久代处于方法区中，实质上方					法区也是堆的一部分
-XX：SurvivorRatio = 4：设置年轻代中Eden区与Survivor区的比值。此处为4，则两个Survivor区与一个Eden区的					   比值为 2:4，所以一个Survivor占年轻代的1/6
-XX：MaxPermSize = 16m：设持久代大小为16M
-XX：MaxTenuringThreshold = 0：设垃圾的最大年龄为0，即年轻代对象不见过Survivor，直接进入年老代，对年老							 代比较多的应用，可以提高效率。若将此值设未较大值，可增加对象在年轻代的时							 间，增加被回收的几率

-XX:+UseSerialGC	:使用串行收集器

-XX:+UseParallelGC	:使用并行收集器，收集年轻代
-XX:+UseParallelOldGC :使用并行收集器，收集老年代
-XX:MaxGCPauseMillis = 100 :每次垃圾回收最长暂停时间为100毫秒，若无法满足，JVM会自动调整年轻代大小
-XX:+UseAdaptiveSizePolicy :并行收集器自动选择年轻代大小，和Survivor区的比例，以达到系统规定的最低响应						   时间。此值在并行收集时，最好一直打开

-XX:+UseParNewGC	:设年轻代为并发收集，JDK5.0后JVM会自动设置，无需再设此值
-XX:+UseConcMarkSweepGC :设年老代为并发收集
-XX:CMSFullGCsBeforeCompaction = 5 :运行5次GC后，对内存空间进行压缩、整理
-XX:+UseCMSCompactAtFullCollection :对老年代进行压缩，可能会影响性能，但可消除碎片
```

##### 2、辅助命令行

```java
-XX:PrintGC
-XX:Printetails
-XX:+PrintGCTimeStamps		可与上面两条组合
-XX:+PrintGCApplicationConcurrentTime	:打印每次垃圾回收前，程序未中断的执行时间，可与上面组合使用
	输出形式：	Application time： 0.XXXXXX seconds
-XX:+PrintGCApplicationStoppedTime		:打印垃圾回收期间，程序暂停的时间，可与上面组合使用
	输出形式：	Total time for which application threads were stopped : 0.XXXXXXX seconds
-XX:PrintHeapAtGC					   :打印GC前后的堆栈信息
```
