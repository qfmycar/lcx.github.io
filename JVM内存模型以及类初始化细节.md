## JVM内容整理	@Author：Lin.cx @Date 2019.07.28

### 一、JVM内存模型

```
JVM内存模型内包括 虚拟机栈、本地方法栈、堆、方法区、程序计数器
```

#### 1、什么是程序计数器

```
程序计数器是线程私有的，是占据内存很小的一块区域，用于指向当前线程运行的行号
```

#### 2、什么是虚拟机栈

```
	虚拟机栈与程序计数器一样，也是线程私有的，用于存储定义的变量，引用的对象、调用的函数等。栈描述的就是Java方法执行的内存模型
	每个方法被执行时都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每个方法被调用的过程就是栈帧进栈出栈的过程。
	
	栈帧是用来存储数据和部分过程结果的数据结构，它在线程的虚拟机栈内大小是由编译期确定的，不受运行期影响
	
	一般我们所说的栈就是指 局部变量表部分
	栈的大小是由编译器决定的，而不是运行期能改变的，当使用的栈大小超出原有的大小，就会报出StackOverFlowError
	可以动态扩展栈容量，但是当申请的栈容量达不到时，就会报出OverOfMemory
```

#### 3、什么是本地方法栈

```
	本地方法栈功能与虚拟机栈类似，区别是虚拟机栈是为Java方法服务的，而本地方法栈是为native方法服务的
```

#### 4、什么是堆

```
	堆是线程共享的，目的是用来存储对象实例，也常称GC堆
	对于大多数应用来说，堆是占据内存最大的一块区域。因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制
	Java虚拟机规范介绍说，所有实例和数组都要在堆中分配内存。不过随着 JIT编译器和 逃逸分析技术的成熟，这已不那么绝对
	
	JIT编译器：将java字节码和需要被解释的的某一指令的程序转换为可直接发送给处理器的指令的程序
	逃逸技术：绝定某些实例是否被存在堆中，如果开启，那么这些数据将被存储在栈中，并且他们的指针可被全局引用	
```

#### 5、什么是方法区

```
	方法区同堆一样，线程共享的内存区域。JDK8中，逻辑上可认为方法区属于堆
	用于存储已被虚拟机加载的类信息、常量、静态变量
	在方法区内还有一个运行时常量池，用来存储字面量和符号引用等
	在jdk1.7之前，常量池也被叫做永久代，在jdk1.7之后，永久代就被删除了，我们可以用java 的interns方法来判断符号引用等存储的位置
```

### 二、类加载机制

#### 1、什么是类的加载

```java
	类的加载是指，类的加载器通过类的完全限定名获取class类文件的二进制字节码数据，存储在内存中，通过验证、准备、解析、初始化，在堆中生成一个代码该类的对象，指向方法区内数据的地址
```

#### 2、类的生命周期

```java
	生命周期包括：加载、验证、准备、解析、初始化、使用、卸载
	其中加载：就是类加载器通过类的完全限定名获取类的二进制字节码数据放到内存中
	
	验证：目的是为了确保数据规范，保护虚拟机
		其中有：
		1.文件格式验证		基于字节流验证
		2.元数据验证			2.3.4都是基于方法区存储结构验证
		3.字节码验证
		4.符号引用验证
	
	准备：给变量分配内存，并且赋予默认值
		如：public static int value = 123;  //分配默认值时 int 4字节 0 ; long 8字节 0 
		这里准备过程过后，value值为默认值0，初始化后才为123
		但也有特例，如final修饰的变量，如：
		public static final int value = 123;
		这个在准备过程后，value值就为123了
		
	解析：在类的常量池中寻找类、接口、字段和方法的符号引用，并将符号引用改为直接引用
	
	初始化：将类按顺序进行初始化，这里顺序是  
		父类静态方法 > 子类静态方法 > 父类构造器 > 父类成员 > 子类构造器 > 子类成员
```

##### 2.1 类加载需知

```java
Java程序对类的使用方式分为两种：  1、主动使用				2、被动使用
	所有的Java虚拟机实现的是：必须在每个类或接口被Java程序“首次主动使用”时才会初始化他们
	主动使用包括：
	1.创建类的实例
	2.访问类或接口的静态内容
	3.使用反射
	4.初始化类的子类
	5.JVM启动时，有被标记的启动类(main)
	6.JDK1.7提供了动态语言支持，REF_getStaitc、REF_putStatic、REF_invokeStatic助记符句柄对应的类，若没初始化则进行初始化
	
加载.class文件的方式
	1、从本地系统加载
	2、网络下载.class文件
	3、zip、jar包中加载
	4、专用数据库中提取.class文件
	5、Java源文件动态编译为.class文件
	
对于静态字段来说，只有直接定义该字段的类才会被初始化
平常可以用 +XX:+TraceClassLoading	来追踪类加载信息

```

##### 2.2 类加载时final的注意点

```java
	在准备阶段，final修饰的静态变量会转变为常量
	常量会在编译期存入到调用这个常量的方法所在的的常量池中。
	本质上，调用该类不会直接引用定义的常量的类，而是从对应方法的常量池取，因此不会对常量所处类进行初始化
例：
	public class Test{
        public static void main(String[] args){
            system.out.println(parent.str);
        }
	}
	
	class Parent{
        public static final String str = "Hello World";
        static{
            system.out.println("parent");
        }
	}
	//这里输出的结果是 Hello World ，没有parent。因为final在编译器吧常量存到调用该方法的常量池里了，换句话说，编译后即使删除Parent的编译文件，依旧能打印出 Hello World

```

##### 2.3 助记符

```java
使用指令 javap -c 进行反编译后可以看到助记符信息

ldc：表示将 int、float或String类型的常量从常量池推送到栈顶
bipush：表示将单字节数据(-128 ~ 127)推到栈顶
sipush：表示将短整型数据推到栈顶
iconst_1：表示将int类型的1推送到栈顶(-1~5，7个数都这样，其中-1 用m1表示)
anewarray：表示创建一个引用类型(类、接口、数组)，推到栈顶
newarray：表示创建一个原始类型(int等)，推到栈顶

```

##### 2.4 random数据对编译的影响

```java
	常量的值在编译期间无法确定时，其值不会被放到调用该常量的方法所在的常量池中
	通过 random获得的UUID，是在运行期获得的
	这时程序运行，会“主动”使用这个常量所在的类，导致这个类被初始化

```

##### 2.5 数组对编译的影响

```java
	创建数组不会引起对象的初始化，只是创建一个实例
	对数组实例来说，其类型是由JVM在运行期动态生成的，其父类型是Object
	对数组来说，JavaDoc经常讲构造数据的元素为compenent，实际上就是将数组降低一个维度的类型
例：
	public class Test5 {
        public static void main(String[] args){
            Child5[] child = new Child5[2];
            System.out.println(child.getClass());
            System.out.println(child.getClass().getSuperclass());
        }
    }

    class Parent5{
        String str = "parent";
        static {
            System.out.println("this is parent");
        }
    }

    class Child5 extends Parent5{
        String str2 = "child";
        static{
            System.out.println("this is child");
        }
    }
这里输出结果为 class [Lcom.cx.test.Child5;//一个[表示是一层数组，[[表示二维数组
		     class java.lang.Object

```

##### 2.6 接口对编译的影响

```
Java虚拟机初始化一个类的时候，要求它所有父类都完成初始化，但这个规则不适用于接口
	-初始化一个类的时候，不会先初始化它实现的接口
	-初始化一个接口的时候，不会初始化它的父接口
	-如果引用的父接口或实现的接口里的数据，不是编译期时存到常量池而是运行期产生的，则会初始化
	接口中的常量默认是static final修饰的，所以可以参考final修饰的情况

```

##### 综合测试：

```java
public class Test{
    public static void main(String[] args){
		system.out.println(Singleton.counter1);
         system.out.println(Singleton.counter2);
    }
}
//命令放在不同位置，得到不一样的接口。准备从头到尾走一次，初始化会再走一次，共两次
class Singleton{
1    public static int counter1;
2    private static Singleton singelton = new Singleton();
3    private Singleton(){
        count1++;//准备阶段的重要意义
        count2++;//准备阶段这里运行完时，counter1 = 1, counter2 = 1
    }
4    public static int counter2 = 0;//初始化阶段，0会把1覆盖掉
}
//这里的执行顺序为： 准备阶段(1 2 4)  初始化阶段(1 2 3 4)

```

#### 3、类的加载器

```java
类的加载器包括：
	1.启动类加载器(根类)		lib\rt.jar
	2.扩展类加载器			 lib\ext\*.jar
	3.应用类加载器			 class.path
	4.用户自定义类加载器		   ClassLoader的子类
	
	使用类加载器的好处是：方便用户读取各种格式的类文件，只要它是二进制的都可以。
	类加载器不需要等到某个类被“首次主动使用”时才加载它，它允许预加载类，如果类有错误，那会在程序首次主动使用这个类时报错

```

#### 4、双亲委派机制

```
	双亲委派机制是用于类加载时，类加载器收到加载某类的请求，但是他不会单独去加载它，而是把这个请求往上一层转发，转发给他的父类加载器，每一层都是如此。到最后这个请求传到启动类加载器，也就是双亲委派机制的最顶端，由他开始加载。如果父类加载器无法加载，再把这个请求转回给子类加载器，让子类加载器加载。
	好处是：保障java的类随着它的加载器一起具备了带有优先级的层次关系，使加载出来的类统一。举个例子，java.lang.Object类，它是所有加载器都要加载的，最终由启动类加载器加载，因此Object类在各个类加载器中都是同一个类。如果没有双亲委派机制，那每个加载器都可对Object进行加载，那应用程序将一片混乱

```
